## 回归问题实现

### 一、回归模型的实现

实现代码：

```python
import numpy as np
from utils.prepare_for_training import prepare_for_training


class LinearRegression:
    def __init__(self, data, labels, polynomial_degree=0, sinusoid_degree=0, normalize_data=True):
        """
        模型初始化
        :param data: 特征值数据
        :param labels: 目标值数据
        :param prepare: 是否进行预处理
        :param polynomial_degree:
        :param sinusoid_degree:
        :param normalize_data:
        """
        # 预处理
        data_processed = data
        features_mean = 0
        features_deviation = 0

        (data_processed,
         features_mean,
         features_deviation) = prepare_for_training(data, polynomial_degree, sinusoid_degree, normalize_data)
        # 预处理后数据
        self.data = data_processed
        # 目标
        self.labels = labels
        # 数据平均值
        self.features_mean = features_mean
        # 数据标准差
        self.features_deviation = features_deviation
        self.polynomial_degree = polynomial_degree
        self.sinusoid_degree = sinusoid_degree
        self.normalize_data = normalize_data

        # 数据列数
        num_features = self.data.shape[1]
        # 初始化参数矩阵
        self.theta = np.zeros((num_features, 1))

    def train(self, alpha, num_iterations=500):
        """
        训练主函数, 执行梯度下降
        :param alpha: 学习率
        :param num_iterations: 迭代次数
        :return: 最终参数,损失值变化
        """
        cost_history = self.gradient_descent(alpha, num_iterations)
        return self.theta, cost_history

    def gradient_descent(self, alpha, num_iterations):
        """
        梯度下降，实际计算函数
        :param alpha: 学习率
        :param num_iterations: 迭代次数
        :return: 损失值变化
        """
        cost_history = []
        for _ in range(num_iterations):
            self.gradient_step(alpha)
            cost_history.append(self.cost_function(self.data, self.labels))
        return cost_history

    def gradient_step(self, alpha):
        """
        参数更新
        :param alpha: 学习率
        """
        # 批处理数量
        num_examples = self.data.shape[0]
        # 预测值计算
        prediction = LinearRegression.hypothesis(self.data, self.theta)
        # 计算真实值与预测值之差
        delta = prediction - self.labels
        # 计算更新参数
        theta = self.theta
        theta -= alpha * (1 / num_examples) * (np.dot(delta.T, self.data)).T
        self.theta = theta

    def cost_function(self, data, labels):
        """
        损失函数
        :param data: 特征值数据
        :param labels: 目标值数据
        :return: 损失值
        """
        num_examples = self.data.shape[0]
        prediction = LinearRegression.hypothesis(self.data, self.theta)
        delta = prediction - self.labels
        # 最小二乘法损失函数
        cost = (1 / 2) * np.dot(delta.T, delta) / num_examples
        return cost[0][0]

    @staticmethod
    def hypothesis(data, theta):
        """
        当前预测值计算
        :param data: 特征值数据
        :param theta: 参数
        :return: 预测值
        """
        predictions = np.dot(data, theta)
        return predictions

    def get_cost(self, data, labels):
        data_processed = prepare_for_training(data,
                                              self.polynomial_degree,
                                              self.sinusoid_degree,
                                              self.normalize_data)[0]
        return self.cost_function(data_processed, labels)

    def predict(self, data):
        """
        用训练好的模型去得到回归值结果
        :param data: 特征值数据
        :return: 回归值
        """

        data_processed = prepare_for_training(data,
                                              self.polynomial_degree,
                                              self.sinusoid_degree,
                                              self.normalize_data)[0]
        predictions = LinearRegression.hypothesis(data_processed, self.theta)
        return predictions
```

- 将模型定义为一个类，然后所有功能都由类中的函数实现
- \__init__()函数:初始化模型，包括传入特征数据和目标数据，还有训练的参数，并且将数据进行预处理
- train()：模型的主函数，执行梯度下降
- gradient_descent()：梯度下降函数，实际执行梯度下降的函数
- gradient_step()：参数更新函数，执行梯度下降中的参数更新
- cost_function()：根据特征数据和目标数据，使用当前的参数来计算损失值，这里用的是最小二乘法的损失函数
- hypothesis()：为一个静态函数，不用实例化类就能调用，根据传入的特征数据和$\theta$参数来计算预测值
- get_cost()：传入其他未预处理的数据来计算损失
- predict()：预测函数，用训练好的模型去得到回归值结果



### 二、单特征线性回归(一元线性回归)

数据下载链接：[world-happiness-report-2017.csv](https://github.com/monarch-beluga/Study-Code/blob/master/Python/MachineLearning/data/world-happiness-report-2017.csv)

我们这里使用的是一个csv数据，所以使用pandas来进行读取，并且会使用matplotlib来进行绘图操作

#### 1、包导入

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 上面实现的回归模型
from linear_regression import LinearRegression
```

#### 2、数据读取和训练数据与测试数据获取

```python
data = pd.read_csv("../data/world-happiness-report-2017.csv")

# 得到训练和测试数据
train_data = data.sample(frac=0.8)
test_data = data.drop(train_data.index)

input_param_name = 'Economy..GDP.per.Capita.'
output_param_name = 'Happiness.Score'

# 获取训练数据的特征值和目标值
x_train = train_data[[input_param_name]].values
y_train = train_data[[output_param_name]].values

# 获取测试数据的特征值和目标值
x_test = test_data[[input_param_name]].values
y_test = test_data[[output_param_name]].values
```

- 注意train_data[[input_param_name]].values使用双中括号，为了保持数据为矩阵

#### 3、用训练数据和测试数据绘制散点图

```python
# 散点图绘制
plt.scatter(x_train, y_train, label='Train data')
plt.scatter(x_test, y_test, label='Test data')
# 设置横纵坐标label
plt.xlabel(input_param_name)
plt.ylabel(output_param_name)
# 设置标题
plt.title('City happiness')
# 图例显示
plt.legend()
# 显示图片
plt.show()
```

![image-20240104000135621](https://img2023.cnblogs.com/blog/2213660/202401/2213660-20240104000137296-1879836436.png)

#### 4、模型训练

```python
# 迭代次数
num_iterations = 500
# 学习率
learning_rate = 0.01

# 模型实例化
linear_regression = LinearRegression(x_train, y_train)
# 训练模型
theta, cost_history = linear_regression.train(learning_rate, num_iterations)
```

#### 5、获取损失，并绘制损失变化图

```python
print('开始时的损失：', cost_history[0])
print('训练后的损失：', cost_history[-1])

plt.plot(range(num_iterations), cost_history)
plt.xlabel('Iter')
plt.ylabel('cost')
plt.title('GD')
plt.show()
```

![image-20240104000500787](https://img2023.cnblogs.com/blog/2213660/202401/2213660-20240104000502414-48526338.png)

#### 6、绘制训练后的回归线

```python
predictions_num = 100
# 用训练样本的最大最小值，并在其中等间距的生成100个点来绘制直线
# 生成数据后用reshape来保证数据为矩阵
x_predictions = np.linspace(x_train.min(), x_train.max(), predictions_num).reshape(-1, 1)
# 用训练好的模型计算预测值
y_predictions = linear_regression.predict(x_predictions)

# 绘图
plt.scatter(x_train, y_train, label='Train data')
plt.scatter(x_test, y_test, label='Test data')
plt.plot(x_predictions, y_predictions, 'r', label='Prediction')
plt.xlabel(input_param_name)
plt.ylabel(output_param_name)
plt.title('City happiness')
plt.legend()
plt.show()
```

![image-20240104000930670](https://img2023.cnblogs.com/blog/2213660/202401/2213660-20240104000932322-1839154710.png)



